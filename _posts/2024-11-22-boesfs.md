---
layout: post
title: "BoesFS: Based on eBPF Sandboxing File System and Its Application"
date: 2024-11-22 21:34:00
description: BoesFS Design and Implementation
tags: eBPF
categories: sample-posts
images:
  slider: true
---

分享的演示文档: [BoesFS分享PPT](/blog/assets/pdf/boesfs.pdf)

<hr>

今天要分享的是，我们2023年os功能赛的一等奖获奖作品：BoesFS，基于eBPF实现的文件系统沙盒及其应用。我是本次技术主讲人杨大荣。这中间已经跨度时间已经较长，并且不同赛题内容相差也很大，技术内容仅供大家参考学习。

<hr>


## 1 背景

我们首先看项目背景。随着无服务FaaS的发展，成千上万的函数被部署到了云端。但着也带来了一个挑战，如何安全且高性能的运行这些非受信的函数。

<hr>


FaaS带来了自定义、细粒度、灵活性和动态性等需求。图中现有的传统访问控制技术往往无法很好满足上述这些需求。

<hr>


而近年来，eBPF如火如荼的发展。其具备优秀的运行时、内核空间和用户空间交互的能力使其在网络等领域得到广泛运用。但在当时，其在文件，尤其是文件安全方向，仍缺乏较成熟的尝试。

<hr>


<u>下面我对eBPF做个简单介绍</u>。这是一种Linux内核的类虚拟机技术。上述两张图取自ebpf.io，感兴趣的同学们可以拓展了解。

（1）如第一张图所示，eBPF可运用的场景包括网络、安全和监测。现在已经有许多基于eBPF的项目和开发工具。例如做系统调用检测的Falco就是其中一个项目。用户态有eBPF应用程序。内核态中进一步提供eBPF检查器、帮助函数、eBPF Map等。

（2）更详细的运行时原理如第二张图所示。这张图以Go环境示例。<u>第一步</u>，C语言的eBPF程序会被编译为字节码。<u>第二步</u>，字节码会被用户态的eBPF应用程序加载，进行验证器的校验和JIT编译后，加载的内核指定的hook点，与此同时eBPF Map也会在此时被创建。<u>第三步</u>，完成这些准备工作后，每当函数执行到内核对应的eBPF hook点，都会运行被加载的eBPF字节码，如图中的红色箭头所示，通过共享的eBPF Map完成和位于用户态的eBPF应用程序的交互。以上就是eBPF的基本运行流程。

<hr>


因此，基于FaaS的新挑战和现有安全访问方式的现状，我们使用新兴工具eBPF进行了尝试。

<hr>


## 2 目标

功能赛是命题赛制，我们当时所选的赛题，要求完成的项目目标包括：实现一个eBPF文件系统沙盒、提供细粒度访问控制、允许自定义安全检查和具备低的性能开销，最后要能提供安全且高性能的FaaS运行环境。我们很好的完成了上述的目标。

<hr>


## 3 设计

### 3.1 总体架构

在具体的设计上，正如前面对eBPF基本原理的介绍，BoesFS的核心主要包括三个模块：第一个是位于用户态的应用程序Agent，第二个是位于内核态的eBPF支持Kernel，第三个是运行时的eBPF字节码检查程序Check Module。

<hr>


运行时结构如这张图所示，在本项目中，eBPF字节码实现为自定义的运行时检查模型ACL/RBAC，用户态通过约定规则动态装载检查规则到eBPF Map，且在每次触发VFS文件请求时，内核态字节码匹配eBPF Map里的检查规则进行检查。

<hr>


### 3.2 BoesFS Kernel 模块设计

各个模块的设计分别如下：由于当时eBPF hook点较少，在细粒度文件控制上没有支持的hook点。我们新定义了一个BoesFS eBPF字节码类型来提供eBPF Kernel的支持。具体实现上，我们基于可堆叠的文件系统作为一个映射和转发层采集所有参数，同时将沙盒状态和eBPF字节码等信息维护在文件系统的超级块上。

<hr>


每次文件请求时，走过VFS函数接口，都会运行字节码程序，触发规则匹配和检查，最后根据结果进行放行或拦截。

<hr>


具体在eBPF Kernel的支持上，我们实现了新类型定义、注册函数、验证器和工具函数集等。

<hr>


为了支持更灵活的使用，我们额外实现了一些其他的功能，例如请求审计、异常进程终止等，这里就不一一概述了。

<hr>


### 3.3 BoesFS Agent 模块设计

在eBPF代理端的设计上，为了能够支持进程粒度的沙箱，我们采用了多级进程管理，父级进程负责装载eBPF字节码、装填规则到eBPF Map等操作，并为子进程创建user namespace。最后子进程会在独立的mount namespace下挂载BoesFS，然后代理运行非受信的函数。

<hr>


在实际实现中，BoesFS沙盒基于信号机制可以灵活的实现运行时的沙盒层替换。

<hr>


### 3.4 BoesFS Check Module 模块设计

在字节码的实现上，字节码运行时获取Kernel采集的内核上下文，和用户空间装填在eBPF Map的ACL/RBAC安全检查规则进行运行时交互。字节码的运行包括三个阶段，阶段1和阶段3是为了实现查询优化实现的目录树构建和销毁。阶段2进行ACL规则查询。

<hr>


eBPF Map基于memlock，其大小和使用受限，需要精心设计。在具体和文件ACL/RBAC请求相结合的设计上，我们分别设计了模型Map，文件Map，目录Map和参数Map，通过bitmap的方式来实现模型和规则的高效存储。具体在规则查询上，eBPF字节码根据灵活地黑白名单、最深父目录规则等方式来找到匹配目标对象的规则逻辑。

<hr>


查询优化是我们在决赛期间实现的优化，基于字典树和目录树优化查询，大幅度提高查询速率。

<hr>


### 3.5 BoesFS FaaS 模块设计

整个项目我们将BoesFS沙盒迁移到主流的Serverless平台Fnproject上。函数在运行时生成沙盒环境，始终收到BoesFS规则的强制保护。

<hr>


BoesFS-FaaS的运行具体运行流如图所示，开发者部署的FaaS函数，每次被客户触发时，我们都会弹性的挂载一个BoesFS沙盒，最终会在BoesFS的可靠计算环境里，返回函数的最终计算结果。

<hr>


## 4 测试

在测试上，我们对BoesFS按照赛题要求进行了完善的功能测试，BoesFS在功能上，实现完备，检查能力覆盖全部VFS接口。

<hr>


在FaaS响应和性能测试上，基于BoesFS轻量级的FaaS比基于容器的FaaS，在响应时间上少很多，高并发条件下的资源开销更小。

<hr>


我们进一步对BoesFS进行了文件系统性能测试，和原生的环境对比，BoesFS各种指标上带来的开销仅在5%。

<hr>


在高IO量的实际场景测试下，在内核压缩、解压和编译等方式的开销均只在7%。和同类工作对比，BoesFS的开销低于同类安全访问控制方式。

<hr>


我们简单对BoesFS项目进行展示：构造的恶意函数，在对应的ACL/RBAC安全检查规则下，成功拦截违法请求，同时能够对输出的文件请求进行安全审计。

<hr>


## 5 总结

最后对BoesFS做简单小结，我们通过eBPF和可堆叠文件系统实现了一个新的eBPF hook点。基于此我们通过eBPF字节码实现了ACL/RBAC访问控制模型，在高性能上，基于轻量级eBPF字节码、堆叠式沙盒层和ACLs查询优化的设计，BoesFS总体的性能开销很低。
